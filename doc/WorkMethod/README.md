## 10x程序员工作法

### 一、开篇

- 本质复杂度（Essential Complexity）：无论怎么做都必须要做的事。

- 偶然复杂度（Accident Complexity）：做事的方法不对，导致要多做的事。

> 大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。

**如何减少偶然复杂度引发的问题？**

学习思考框架及四个原则：

- 以终为始
- 任务分解
- 沟通反馈
- 自动化

开发效率不是写代码的效率。细节不确认就动手，后期还会反复，更浪费时间。

### 二、思考框架

- **面对问题时，用思考框架问问自己，现状、目标和路径。**

> 头脑风暴：三个问题

- 我现在是个什么水平？
- 我想达到一个什么水平？
- 我将怎样到达那个目标？

> 思考框架

- Where are we？（我们现在在哪？**现状**）=>（**我很清楚**）
- Where are we going？（我们要到哪儿去？**目标**）=>（**以终为始**）
- How can we get there？（我们如何到达那里？**实现路径**）=>（**任务分解、沟通反馈、自动化**）

>四个思考原则

- 会带来怎样的价值？
- 怎样使用？
- 是否是唯一的手段？
- 如何衡量它的有效性？

> 哲学的三个终极问题

- 我是谁？
- 我从哪里来？
- 我要到哪里去？

### 三、以终为始

> 一种反直觉的思维方式：以终为始。

- **遇到事情，倒着想**。
- 做事之前，先想想结果是什么样子的。
- 想象共同体：集体对同一个目标达成的共同想象。
- 任何事物都要经过两次创造：
  - 一次时在头脑中的创造，也就是智力上的或者第一次创造（Mental/First Creation）。
  - 然后才是付诸实践，也就是实际的构建或第二次创造（Physical/Second Creation）。
  - 相对于第一次创造，第二次创造是一件成本很高的事。
- 代码的终点是测试，所以要测试驱动开发。
- 交付一个一直可运行的软件，所以要持续集成。
- 输出倒逼输入。
- 亚马逊开发一项产品的顺序：
  - 写新闻稿。
  - 写FAQ（常见问题解答）。
  - 写用户文档。
  - 写代码。

> DoD（Definition of Done，完成的定义）

- **在做任何事之前，先定义完成的标准**。
- DoD是一种思维模式，是一种尽可能消除不确定性，达成共识的方式。
- 任务开发只有两种状态：完成/未完成。
- 例如：
  - 特性开发完成：需求澄清、功能设计、编写代码、单元测试、测试人员验收、相关文档编写完毕。
  - 开发完成：编写功能代码、测试代码、集成测试代码，且测试可通过，代码风格检查、测试覆盖率检查。

> 验收标准

- **在做任何需求或任务之前，先定义好验收标准。**（最好维护的代码是没有写出来的代码）
- ”用户故事“
  - 标题：主要功能，比如：注册用户使用用户名密码登录。
  - 概要：As a（Role），I want to（Activity），so that（Business Value）。
    - 作为一个什么角色，要做什么样的事，以便达成一种怎样的效果。
    - 比如：作为一个注册用户，我想要通过用户密码登录，以便我可以使用注册用户才能够使用的服务。
  - 详述：详细地描述这个用户故事的完整流程。
    - 比如：用户使用正确的用户名密码登录，就登录成功，否则登录页提示用户“用户名密码不正确”。
  - 验收标准：描述一个正常使用的流程是怎样的，以及各种异常流程系统是如何给出响应的。
    - 比如：正常场景，给定一个注册用户，使用正确的用户名密码登录，成功则跳转到用户中心。异常场景：给定一个注册用户，使用错误的用户名或密码登录，失败则在登录页提示“用户名密码不正确”。
    - 验收标准，它可以清晰地定义出需求边界。
    - 其重要环节是异常流程的描述，人们往往擅长解决正常流程，而忽略掉异常流程。
- 扮演不同角色的时候，我们的思考模式是不同的
  - 开发人员：输入正确的用户名和密码可以正常登陆，否则不能登陆，且给出提示。
  - 产品经理：登陆是否需要验证码、是否需要第三方登陆、用户名密码的长度是否有限制...

> 持续集成

- **尽早集成**。

- 1996年，Steve McConnel出版《Rapid Development》，国内译作《快速软件开发》。在这本书中，作者首次提出了解决集成问题的优秀实践：**Daily Build，每日构建**。
  - 只要增加集成的频率，就可以保证在每次集成时有较少的改动量，从而降低集成难度。
  - 基于这样的想法，有人尝试着让开发和集成同时进行，诞生了一个关于集成的全新实践：**持续集成**。
- 2000 年时，“软件行业最会总结的人” Martin Fowler 发布了一篇重量级文章“**Continuous Integration**”。

- 之后一年，由 Martin Fowler 所在的 ThoughtWorks 公司发布了市面上第一款持续集成服务器 CruiseControl。
- 2006 年，Martin Fowler 重写了“Continuous Integration”这篇文章。之后人们更是以持续集成为基础，进一步拓展出**持续交付**的概念。

> 精益创业

- **默认所有需求都不做，直到弄清楚为什么要做这件事。**
- 要有自己的独立思考，**多问几个为什么**，尽可能减少掉到“坑”里之后再求救的次数。
- 软件开发的主流由**面向确定性问题**，逐渐变成了**面向不确定性问题**。
- 最早面向不确定性创造新事物的方法论是精益创业（Lean Startup），它是Eric Ries最早总结出来的，最终在2011年写成一本同名的书《精益创业》。
- 不确定，就得“试”。
- 开发（build）=> 测量（measure）=> 认知（learn）反馈循环。
- 将想法**开发**成产品投入市场，收集数据（**测量**），验证（**认知**）想法。
- MVP（Minimum Viable Product）最小可行产品（少花钱，多办事）。

> 上下文

- **扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。**

- 技术解决不了的，可以尝试用非技术手段解决。
  - 比如：坎需求，一些无用、逻辑不通、以后的需求可以砍掉。
- 跳出程序员角色的思维，扩大自己工作的上下文。
  - 比如：了解软件开发的生命周期之后，你看到的不再是一个点，而是一条线。
- 上下文问题，也就是沟通问题。
  - 看下别人是怎么想的，或许自己的问题，在别人眼里都不是问题。
- 扩展上下文的同时，也是在提升自己的竞争力。
  - 通过扩展自己的上下文，可以提前了解到上一级的能力素质和思考方式，做好了机会也就来了。

> 沙盘推演

- **在动手做一件事之前，先推演一番。**
- **”最后一公里“**指的是完成一件事，在最后也是最关键的步骤。
  - 比如：上线需要考虑哪些因素，推演出一步步可执行的上线方案，将这些因素作为衡量指标，总结要做的任务。
- 通向结果的**路径**才是更重要的。
  - 很多情况下，即便目标清晰，路径却是模糊的。
- 在做一个产品之前：
  - 产品是如何推广的，通过什么途径推广给什么样的人。
- 在做技术改进之前：
  - 上下是怎样一个过程，为可能出现的问题准备方案。
- 在设计一个产品特性之前：
  - 考虑数据由谁提供，完整的流程是什么样的。

> 拿数字说话

- **问一下自己，我的工作是不是可以用数字衡量。**

- 一些人说，自己靠**直觉**就能把事情做好，其实这是一种误解。
  - 所谓的直觉，通常是一种**洞见（Insight）**。
  - 洞见很大程度上依赖于一个人在一个领域长期的沉淀和积累，而这其实是某种意义上的**大数据**。
- 人工智能
  - **算法**几乎是行业共有的。
  - **算力**在云计算普及的今天也不是稀缺资源。
  - **数据**几乎成了兵家必争之”物“。（各个公司都在努力地搜集各种数据，让数据成为自己的竞争力）
- 当事情复杂到一定程度时，简单地靠感觉是很难让人相信的。
- 从数字中发现问题，让系统更稳定。（AIOps，通过人工智能的方式，从数据中发现更多运维的问题）

> 迭代0

- **设计你的迭代0清单，给自己的项目做体检。**

- 迭代0，可以理解为开发的准备阶段。
- 根据优先级来确定迭代1要做的需求，然后进行细化迭代0。
- 给出用户界面和用户交互。
- 持续集成：还包括构建IDE工程、代码风格检查、常见的bug模式检查、测量覆盖率等等。CI Monitor 软件。
- 将测试当做规范确定下来的办法就是把测试覆盖率加入构建脚本。
- 数据库迁移工具flyway。
- 一开始就把部署或发布过程自动化。

<img src="https://static001.geekbang.org/resource/image/b9/55/b9fd38bcb05c2e918d231154a0af1655.jpg" alt="img"/>

> 如何管理上级

- 对不合理的要求说“不”。
- 把自己看到的问题暴露给上级，让让选择。
- 帮助上级丰富知识。
- 说出你的想法。
- 不合理的部分应该是他和老板**去沟通**的，而不是让开发团队**来实现**。
- “抄”不是问题，问题是无脑地抄。
- 分清楚两件事：需求和技术。

> 总结

最佳实践：

- DoD，确定好完成的定义，减少团队内部的理解不一致。
- 用户故事，细化出有价值的需求。
- 持续集成，通过尽早集成，减少改动量，减低集成的难度。
- 精益创业，减少过度开发不确定性产品带来的浪费。
- 迭代0，在项目开始之前，做好一些集成准备。

思维转变：

- 任何事物都要经过两次创造：一次是在头脑中的创造，然后是付诸实践，也就是实际的构建。
- 在更大的上下文内发现自己的“终”。
- 通过推演，找到通往“终”的路径。
- 用可度量的“数字”定义自己的“终”。

### 四、任务分解

> 任务分解

- **动手做一个工作之前，请先对它进行任务分解。**

- 将一个原本毫无头绪的问题，分成若干个可以尝试回答的问题。
- 一个大问题，我们都很难给出答案，但回答小问题却是我们擅长的。
- 这种思路的难点在于，给出一个可执行的分解。
  - 经典段子：这个工作已经做完了80%，剩下的20%还要用和前面的一样时间。
- 不同的可执行定义差别在于，你是否能清楚地知道这个问题该如何解决。
- 计划通常赶不上变化，所以计划也要不断变化。

> 测试

- **多写单元测试。**

- 内建质量（Build Quality In）。
  - 软件变更成本，它会随着时间和开发阶段逐步增加。
  - 只有在开发阶段把代码和测试写好，才有资格说，自己交付的是高质量的代码。
- 自动化测试
  - 其作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。
- 测试模型
  - 冰淇淋蛋卷测试模型。
    - 一种直觉的做法是，先手工测试、端到端测试、集成测试，最后才是单元测试。
  - 测试金字塔。（最佳实践）
    - 越是底层的测试，牵扯到相关内容越少，而高层测试则涉及面更广。
    - 小事反馈周期短，而大事反馈周期长。

> 测试驱动开发

- **编写可测的代码。**

- 测试驱动开发（Test Driven Development，TDD）
  - 红表示写了一个新的测试，测试还没通过的状态。
  - 绿表示写了功能代码，测试通过的状态。
  - 重构表示在完成基本功能之后，调整代码的过程。
    - 有了测试，你就可以大胆地重构；没有测试，你只能提心吊胆地重构。
    - 没有重构，代码的混乱程度是逐步增加的，测试也会变得越来越不好写。

- 测试先行开发（Test First Development）
- 测试驱动设计（Test Driven Design）
  - 由测试驱动代码的编写。
  - 编写可测试性的代码。

>TDD

- 将任务拆小，越小越好。

- 从前TDD只在小圈子里流行，真正让TDD广为人知的是Kent Beck的《解析极限编程》（Extreme Programming Explained）。
  - 极限编程之所以叫”极限“，它背后的理念就是把好的实践推向极限。
- 除了极限编程，还有特征驱动开发、水晶开发方法等等，正是这些开发方法的探索，才有了后面敏捷方法的诞生。
- 任务分解，每个任务完成之后，代码都是可以提交的。
- 小的任务，以保证随时都可以停下来。

> 练习任务分解

**按照完整实现一个需求的顺序安排分解出来的任务。**

需求：用户通过输入用户名和密码登录。

需求列表：

- 用户注册用户名密码。
- 注册用户通过输入用户名和密码登录。
- 登录用户退出。

技术方案：

- 设计用户信息表。
- 数据库迁移工具选型。
- 编写用户信息表的数据库迁移。

开发任务：

- 编写User对象，包含用户名、密码和其他用户基本信息。
- 在UserRepository中，编写save方法，保存新创建的User对象。
- 在UserService中，编写register方法，实现用户注册。
- 在UserResource中，编写register方法，调用UserService的register方法。
- 在UserService中，编写login方法，实现用户登录。
- 在UserResource中，编写login方法，调用UserService的login方法。
- 在UserService中，编写Logout方法，实现用户退出。
- 在UserResource中，编写logout方法，调用UserService的logout方法。

登录成功，用Redis共享数据。

- 在构建脚本依赖中添加Redis的依赖。
- 在构建脚本依赖中添加JSON的依赖。
- 编写UserSession，包含用户名、登录时间和用户Token等。
- 在UserService中，编写login方法，将UserSession放入Redis。
- 在UserService中，编写logout方法，将UserSession从Redis中删除。
- 在存储到Redis时，将对象序列化成JSON。取出时将JSON反序列化成对象。

访问控制：

- 在UserService中，编写login方法，将UserSession放入Redis，返回UserSession。
- 在UserResource中，编写login方法，调用UserService的login方法，并根据返回UserSession设置HTTP头。
- 编写AccessFilter，根据待访问地址，确定是否进行用户登录信息校验。

> 测试标准

- **要想写好测试，就要写简单的测试。**
- 把测试写简单，简单到一目了然，不需要证明他的正确性。
- 测试的基本结构：前置准备、执行、断言和清理。测试一定要有断言。
- A-TRIP
  - Automatic（自动化）：将测试尽量交由机器去做，人工参与的部分越少越好。
  - Thorough（全面的）：尽可能用测试覆盖各种场景。
    - 写代码之前：正常的、异常的、各种边界条件。
    - 写代码之后：测试是否覆盖了所有的代码和所有的分支。
  - Repeatable（可重复的）：
    - 某一测试反复运行，结果应该是一样的。
      - 每个测试本身都不应该依赖于任何不在控制之下的环境。
      - 如果有，则通过模拟外部服务，测试回滚等手段解决。
    - 一堆测试反复运行，结果应该是一样的。这说明测试和测试之间没有任何依赖。
  - Independent（独立的）：测试和测试之间不应该有任何依赖。
    - 如果有，则通过测试框架的前置准备和后置清理解决。
  - Professional（专业的）：
    - 按照代码的标准去维护，比如：良好的命名，把函数写小，要重构，甚至要抽象出测试的基础类。
    - 编写可测试的代码。

> 需求分解

- **想要管理好需求，先把需求拆小。**

- 主题（epic），在敏捷开发中，也称主用户故事（master story）。

- 绝大多数问题都是由于分解的粒度太大造成的，少有因为粒度太小而出问题。
- 用户故事的衡量标准（INVEST原则）：
  - Independent（独立的）。
    - 一个用户故事应该完成一个独立的功能。
    - 尽可能不依赖于其它用户故事。（为了更好的管理优先级、预估工作量）
    - 如果有依赖，一种好的做法是，将依赖部分拆出来，重新调整。
  - Negotiable（可协商的）。
    - 用户故事，之所以是故事，就是要讲，要沟通。
    - 协商可以更好的暴露细节，更好的分解用户故事。
  - Valuable（有价值的）。
    - 一个用户故事都应该有其自身价值，没有价值的事不做。
  - Estimatable（可估算的）。
    - 不能估算的用户故事，要么是因为有很多不确定的因素，要么是因为需求还是太大。
  - Small（小）。
    - 小的用户故事方便调度，才好安排工作。
  - Testable（可测试的）。
    - 验收标准，怎样才算是工作完成。
- 需求估算
  - 估算的结果是相对的，不是绝对精确的。
  - 估算的过程也是大家加深对需求理解的过程。
  - 理解用户故事，比如：
    - 你觉得3个点，我觉得2个点，我们协调一下就好。
    - 你认为2个点，我认为8个点，我们就需要好好沟通一下，看看差异在哪。
  - 估算任务，比如：
    - 1点的用户故事要用1天完成。
    - 而你团队的迭代周期是两周，也就是10个工作日。
    - 那13点的任务是无论如何都完不成的。
  - 用户故事有可能经历两次拆分，一次是业务需求的拆分，另一次是估算阶段发现大用户故事的拆分。
- 用户故事，需求调整的不是一个大主题，而是一个个具体的用户故事。
- 用户故事相关书籍，Mike Cohn的两本书《User Stories Applied》和《Agile Estimating and Planning》。

> 需求管理

- **尽量做最重要的事。**

- “来自老板”不应该成为优先做事的指标。
- 为什么要区分优先级？因为时间有限，所以这也是一个时间管理的问题。
- 由美国前总统艾森豪威（Eisenhower Matrix）开发的一个有效的时间管理策略。后经史蒂芬-柯维（Stephen Richards Covey）的那本《高效能人士的七个习惯》书籍将其推广至世界各地。

![img](https://static001.geekbang.org/resource/image/d0/ea/d049f654dc5ba5a0ba456cde1bb0deea.png)

- 如果不把精力放在重要的事情上，到最后可能都变成紧急的事情。
- 分清楚重要的事情、大局观、降维攻击、扩展上下文。

>最小代价

- 做好产品开发，最可行的方式是采用MVP。

- 验证一个想法的可行性，不是为了开发一个软件，开发软件只是一种验证手段。
  - 先做一个产品文档，拿给用户看，不断验证和改进这个产品文档。
- 可行的路径：不是一个模块做得有多完整，而是一条用户路径是否通畅。
  - 先完成主要功能，阶段性的上线新功能。
  - 当时候有限时，我们需要学会找到一条可行的路径，在完整用户体验和完整系统之间，找到一个平衡。

> 问题

- 在项目中遇到你不熟悉的技术时，就先把它变成你熟悉的技术。
  - 怎么变成你熟悉的技术，做一次技术Spike。（调研，快速的试，需要固定的时间，为了消除不确定性）
  - 关注应用场景，围绕结果的试。
  - 采用这项技术，就必须丢弃掉你的原型代码。只有这样，你才会去做设计，抛弃直接依赖，隔离第三方技术。
- 目标与现状：项目时间紧，没时间做测试。反之，不忙了，你知道该怎么改进吗？所以忙是一种借口。
  - 目标是100%测试，为了达成这个目标，需要做一个任务分解。
  - 一个是与人沟通，另一方面试自动化的过程。
  - 改进过程：把测试覆盖率检查加入到工程、初始化测试覆盖率值、每周将测试覆盖率调高。
- 两个需求同时开发，单分支上线不同步的情况。
  - Feature Toggle是最常用的解决方法，也就是通过开关，决定哪个功能时对外可用的。
  - 对遗留系统做改造，传统做法是，拉出一个分支。如果在一个分支上怎么做呢？
    - 可以考虑采用Branch by Abstraction，也就是在动手改造之前，先提取出来一个抽象，把原来的实现变成这个抽象的一个实现，在改造的过程就是提供这个抽象的一个新实现。

> 总结

- 测试金字塔
  - 多写单元测试。
- 测试驱动开发
  - 红-绿-重构，重构是关键（区分测试先行）。
  - 理解成了测试驱动设计，思维的转变是编写可测试的代码。
- 艾森威尔矩阵（Eisenhower Matrix）
  - 将事情按照**重要**和**紧急**进行划分。
  - 重要且紧急（立即做）；重要不紧急（重点投入精力）；紧急不重要（委托别人做）；不重要不紧急（少做）
- 最小可行性产品
  - “刚刚好”满足客户需求的产品。
  - 在实践中，要用最小的代价找到一条可行的路径。
- 做法和评判标准
  - 尽量不写static方法。
  - 主分支开发模式是一种更好的开发分支模型。
  - 好的用户故事应该符合INVEST原则。
  - 估算是一个加深对需求理解的过程，好的估算是以任务分解为基础的。
  - 好的测试应该符合A-TRIP。
- 思想
  - 分而治之，是人类解决问题的基本手段。
  - 软件变更成本，它会随着时间和开发阶段逐步增加。
  - 测试框架把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。
  - 极限编程之所以叫”极限“，它背后的理念就是把好的实践推向极限。
  - 大师级程序员的工作秘笈是任务分解，分解到可以进行的微操作。
  - 按照完整实现一个需求的顺序安排开发任务。

### 五、沟通反馈

> 沟通反馈

- **通过沟通反馈，不断升级自己的编解码能力。**

- 人生不如意的事，十有八九！真实原因往往是你想得太美好。
- 为什么想得太美好，是因为你对世界的理解出现偏差。
- 我们学习各种知识，就是为了更好地理解这个世界运作的方式。
- 通信模型
  - 信源（Information Source），负责产生消息（Message）。
  - 发送器（Transmitter），对信息进行某些操作，也就是对信息编码，产生信号（Signal）。
  - 信道（Chanel），信号传送的媒介。
  - 接收器（Receiver），对信号执行发送器的逆操作，解码信号，提取出信息。
  - 信宿（Destination），负责接收信息。
- 当编码和解码不是一个版本的时候，无论如何，信息都很难准确地传达到你这里。
- 因为每个人经历见识的差异，造成了各自编解码器的差异。
- 打开接收器，接纳信号，让反馈进来；扩展见识，提升自己的解码器，更好地理解别人要表达的内容。
- 编解码器算法也就是怎么协调沟通双方更有效地进行沟通。
  - 比如：完成的定义。

> 编写可维护的代码

![img](https://static001.geekbang.org/resource/image/aa/79/aa930574f3fac635d51c9c36c9b28e79.png)

- **用业务的语言写代码。**
- 计算机科学中只有两大难题：缓存失效和命名。—— Phil Karlton
- 任何人都能写出计算机能够理解的代码，只有好程序员才能写出人能够理解的代码。—— Martin Fowler
- 用业务语言编程。

>开会

- **多面对面沟通，少开会。**

- 开会是一种重量级的沟通方式。
  - 凡是效果特别好的会议，基本上都是用来做信息同步的。
  - 效果不好的会议，几乎都是那些讨论会。
- 改善会议
  - 减少参与讨论的人数。
  - 如果你要讨论，找人面对面沟通。
- 站立会议（Standup）
  - 站会不会超过10分钟。
  - 说三件事：我昨天做了什么？我今天打算做什么？我在过程中遇到了什么问题，需要请求帮助。

> 可视化

- **多尝试用可视化的方式进行沟通。**

- ThoughtWorks技术雷达
  - ”采用“，表示强烈推荐。
  - “暂缓”，表示新项目别再用这项技术了，这项技术可能已经有了更优秀的替代品。

- 可视化的优势
  - 处理图像的速度远远快于处理文字。
  - 看数字就是典型的数据可视化，而技术雷达就属于信息可视化。
  - UML统一建模语言、流程图等。
- 看板
  - 看板是一种项目管理工具，它将我们正在进行的工作变得可视化。
  - 把工作分成了几个不同的阶段，在看板上对应不同列，每完成一张卡片，就挪到下一个阶段。
  - 技巧：不同颜色的卡表示不同类型的工作，每个人一个头像，增添一些乐趣。
  - 发现问题：正在进行的任务远远大于人数，一定是有问题的，应当限制WIP（Work-In-Progress）。
  - 实体墙：建议使用，优势在于增强了人与人的互动。
  - 电子墙：不推荐使用，除非地方太小，远程协作办公，优势在于随处可访问、数据不会丢失、便于统计等等。两者结合是通过显示屏当做看板。

>快速反馈

- 持续集成的关键点：**快速反馈**。

  - 怎样快速地得到反馈。

  - 什么样的反馈是有效的。

- 提交纪律：

  - 只有CI服务器处于绿色的状态才能提交代码。
  - CI服务器一但检查出错，要立即修复。

- 做好持续集成的关键点：

  - 用好本地构建脚本，保证各种各样的检查都可以在本地环境执行。
  - 用好CI监视器，怎么引人注目，怎么呈现。

> 复盘

- **定期复盘，找准问题根因，不断改善。**

- 把过程还原，进行研讨与分析的方式，就是复盘。
- 用别人的视角看问题，这就是客体化。
- 回顾会议：
  - 主题：做得好的、做得欠佳的、问题或建议。
  - 主题分类：继续保持、开始做、停止做、多做一些、少做一些。
  - 写事实，不要写感受，一张便签一条事实，方便分类。
  - 关注现状，找出解决方案，给出行动项，并且每个行动项都是可检查的。
- 多问5个为什么。
  - 5不是一个参考数字，不是目标。
  - 顺着一条主线追问。

> 吃自家狗粮

- **多走近用户。**

- 拥有用户视角，倾听用户的声音。
- 使用自家的产品，会让你多出一个用户的视角。
- 当吃不到狗粮时，尽可能找机会，去到真实场景里，看看用户是如何使用我们软件的。
- 当产品没有用户时，使用最小MVP，快速得到用户反馈，用业务的语言去沟通，去写代码。
- 谁离用户近，谁就有发言权，无论你的角色是什么。

>高效工作

- 用尽可能小的时间颗粒度来安排自己的工作。
  - 《五分钟商学院》的作者刘润老师曾提到过时间颗粒度的概念。
  - 王健林的时间颗粒度是十五分钟，比尔盖茨的时间颗粒度是五分钟。
- 学而不思则罔，思而不学则殆。一学二懂三要用。
- 多思考、多提问、多练习。
- 以结果为导向。
- 站在不同角色角度看问题。

> 尽早暴露问题

- **事情往前做，有问题尽早暴露。**

- 遇到问题，最好的解决方案是尽早把问题暴露出来。
- Fail Fast，如果遇到问题，尽早报错。
  - 比如：不要设置默认值，去兼容各种问题，而是将问题抛出去，提示非法参数异常，特别是一些必填的参数，记住，别给自己挖坑！
  - 比如：配置文件缺少了一个重要的参数，安照Fail Fast，少了就报错。
- 心理障碍
  - 尽早暴露问题很容易接受，但是在工作中暴露自己的问题，会不会让人觉得自己不行。
  - 每个人的能力是强是弱，大家看得清清楚楚，只有你能把问题解决了大家才会高看你。
  - 把自己的工作透明化，让别人尽可能多地了解自己的工作进展，了解自己的想法。
  - 这种方式的好处是，越往前做，给人留下的空间和余地越大，而不是到最后一刻出现问题的成本过高，让人无法承担。

> 机构化

- **多输出，让知识更有结构。**

- 很多人回避写文档的真正原因是，他掌握的内容不能很好地结构化。
- 将零散的知识结构化，有很多种方式，但输出是非常关键的一环。
- 输出的过程，本质上就是把知识连接起来的过程。
- 金字塔原理
  - 中心论点
  - 分论点
  - 论据

> 问题

- 单元测试做不好，是否会影响到 CI 的效果？
  - 集成测试的价值在于，它是一条主线，可以将诸多实践贯穿起来。
  - 懂任务分解->频繁提交->稳定的开发分支->做好CI。
  - 懂软件设计->编写可测的代码->多写单元测试->测试防护网->做好CI。
- 老板参加复盘，不敢说真话怎么办？
  - 暴露问题，是改进的前提条件。
  - 做安全性检查，放心地把问题暴露出来。
- 国内的技术信息落后吗？
  - 国内程序员真正落后的不是信息，而是观念。
  - 边际效用递减法则（The Law Of Diminishing Marginal Utility），说的是当你手里某一物品总数越来越多时，新增一个单位该物品所获得的效用通常会越来越少。

> 总结

- 看板
  - 一种来自精益生产的可视化实践。
  - 按阶段将任务放置其中。
  - 可以帮助我们发现问题。
- 持续集成
  - 做好持续集成的关键是，快速反馈。
  - 找到有效的反馈方式，比如：CI监视器。
  - 持续集成的纪律。
    - 只有CI服务器处于绿色的状态才能提交代码。
    - CI服务器一但检查出错，要立即修复。
- 回顾会议
  - 软件团队复盘的一种实践。
  - 枚举关注点，选出重点，深入讨论，列出行动项，找到负责人。
- 5个为什么
  - 又一个来自丰田的实践。
  - 沿着一条主线追问多个问题。
- 思路
  - 用信息论理解沟通反馈。
  - 写代码的进阶路径。
    - 编写可以运行的代码。
    - 编写符合代码规范的代码。
    - 编写人可以理解的代码。
    - 用业务语言写代码。
  - 会议是一种重量级的沟通方式。
    - 减少参会人数。
    - 找人面对面沟通。
  - 聆听用户声音
    - 能做自己用户，做自己的用户。
    - 能接近用户，接近用户。
    - 没有用户，创造用户。
  - Fail Fast
    - 一种编写代码的原则。
    - 出现问题尽早报错。
  - 金字塔原理
    - 从中心论点，到分论点，再到论据。

### 六、自动化

> 重构

- **锻炼你的重构技能。**
- 热力学第二定律：如果没有外部干预，系统会朝着越来越混乱的方向发展。
  - 对抗熵增的一个办法就是引入负熵，让系统变得更加有序。
  - 而在代码中引入负熵的过程就是“重构”。
- 重构是一种微操作。
  - 重写（rewrite）并非重构（refactoring）。
  - 将代码分解成若干可以单独进行的“重构”小动作，然后一步一步完成它。
  - 每一步都可以很快完成，而且每完一步都是可以停下来的。
- 重构地图
  - 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
  - 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
  - 为什么要调整软件的内部结构，因为嗅到了代码的坏味道。
- 可变数据（Mutable Data）、循环语句（Loops）都定义成了坏味道。
- 函数式编程已然成为时代的主流。
- 重构的刻意练习：试试维护自己三个月甚至更久前的代码？

> ”懒惰“

- **请谨慎地将工作自动化。**

- 优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness，Impatience and hubris）。——Perl语言发明人Larry Wall。
  - 懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完美的文档，以免别人来问问题。
  - 急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。
  - 傲慢，极度自信，写出（或维护）别人跳不出毛病的程序。
- 做有价值的事最重要，这里面的有价值，不仅仅是“做”了什么，通过“不做”节省时间和成本也是有价值的。
- NIH综合征（Not Invented Here Syndrome）：看不上别人做的东西，非要自己做出一套来。
- 你的日常工作室给别人打造自动化，但你自己的工作够自动化吗？
- 给别人打造自动化工具中需要的能力：软件设计。
  - 区分设计和实现。
  - 在软件开发中，其它的东西都是易变的，唯有设计的可变性是你可以控制的。

> 构建脚本Gradle

- **将你工作过程自动化。**

- 生成IDE工程

  - `gradlew ide` # 构建ide工程
  - 安装 Lombok 插件，然后，在 “Build, Execution, Deployment”-> “Compiler” -> “Annotation Processors“”中，选中 Enable annotation processing。

- 配置文件

  - build.gradle，Gradle的配置文件，由Groovy编写，本质上就是一个Groovy的脚本。
  - settings.gradle，如果说一个项目中的每个模块都有一个build.gradle，那整个项目只有一个settings.gradle。
  - 在Gradle里，很多能力都是以插件的形式提供的。
  - 例如：`apply plugin: 'idea'`就是生成IDEA工程的一句配置。

- 工程目录

  - src/main/java # 放源代码
  - src/main/resources # 放配置文件
  - src/test/java # 放测试代码
  - 这就是约定优于配置（Convention over Configuration）思想的体现。

- 检查

  - `./gradlew check` # 检查
  - `apply plugin: 'checkstyle'` # 应用代码风格检查插件
    - `style.excludePackages = []` # 指定某些包不做检查
    - `style.excludeClasses = []` # 指定某些文件不做检查
  - `apply plugin: 'jacoco'` # 应用测试覆盖率检查插件
    - `coverage.excludePackages = []` # 指定某些包不做检查
    - `coverage.excludeClasses = []` # 指定某些文件不做检查

- 数据库迁移（flyway）

  - ~~~yaml
    plugins { id "org.flywaydb.flyway" version "5.2.4"}
    ~~~

  - ~~~yaml
    flyway {
    	url = 'jdbc:mysql://localhost:3306/zero_test?	
    					useUnicode=true&characterEncoding=utf-8&useSSL=false'
        user = 'zero' 
        password = 'geektime'
        locations = ["filesystem:$rootDir/gradle/config/migration"]}
    ~~~

  - ~~~sql
    CREATE TABLE zero_users(
        id bigint(20) not null AUTO_INCREMENT,
        name varchar(100) not null unique,
        password varchar(100) not null, primary key(id)
    );
    ~~~

  - `./gradlew flywayMigrate` # 迁移

- 构建应用

  - `./gradlew build` # 生成构建产物

  - 这个命令会在zero-bootstrap/build/libs下生成一个可执行JAR包。

  - 此外，build任务会依赖于check任务，也就是说，构建之前，会先对代码进行检查。

  - `./gradlew bootRun` # 直接运行

  - `http://localhost:8080/users` # post请求
  
  - 
    ~~~json
    { "username": "foo", "password": "bar"}
    ~~~
  

> 学习运维知识

- **有体系地学习运维知识。**

| 类别     | Java                                                         | 运维                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语言     | Java语言                                                     | Shell                                                        |
| 核心库   | JDK                                                          | Unix/Linux核心命令                                           |
| 第三方库 | 第三方程序库，比如：Google Guava、SLF4J                      | 第三方命令，比如：rsgnc、curl等                              |
| 开发框架 | 开发框架，比如：Spring                                       | 配置管理工具，比如：Chef、Puppet、Ansible等                  |
| 单机部署 | 应用服务器，比如：Tomcat、Jetty                              | 部署环境，比如：虚拟机、Docker等                             |
| 集群部署 | 企业级应用服务器，比如：IBM WebSphere、Oracle Weblogic Server、JBoss Enterprise Application Platform | 云服务，比如：Amazon Aws、OpenStack、阿里云；Docker集群，比如：Kubernates、Docker Swarm等 |

> 持续交付

- **将部署纳入开发的考量。**

- 持续交付，就是一种让软件随时处于可以部署到生产环境的能力。
- 验证发布包：
  - 持续集成环境，持续集成是持续交付的前提，这个过程主要是执行基本的检查，打出一个可以发布的包。
  - 测试环境（Test），这个环境往往是单机的，主要负责功能验证，运行的测试基本上都是验收测试级别的，而一般把单元测试和集成测试等执行比较快的测试放到持续集成环境中执行。
  - 预生成环境（Staging），这个环境通常与生产环境配置是相同的，比如，负责均衡，集群之类的都要有，只是机器数量上会少一些，主要负责验证部署环境，比如，可以用来发现由多机并发带来的一些问题。
  - 生产环境（Production），真实的线上环境。
- 按照不同阶段组织构建的方式，称之为构建流水线（Build Pipeline）。
- 最后一步是由人来决定是否上线的，如果将其变成自动化的，就成了另一个实践：持续部署。
- 通常人们都会比较谨慎，最后这一下还是由人拍板比较稳妥，所以，持续交付是现在的主流。
- DevOps（开发Development和运维Operations）
  - Docker镜像
  - 基础设施即代码（Infrastructure as code）

> 验收测试（Acceptance Testing）

- **将验收测试自动化。**
- 验收测试，是确定应用是否满足设计规范的测试。这种测试往往是站在用户的角度，看整个应用能否满足业务需求。
- 行为驱动开发（Behavior Driven Development，BDD），指的是业务行为。BDD希望促进业务人员与开发团队之间的协作，换句话说，如果你想做BDD，就应该用业务语言进行描述。
- BDD是2003年由Dan North提出来的，并创造了第一个BDD的框架：JBehave。后来有改写出基于Ruby的版本，这个项目后来被并到RSpec中。
- 今天最流行的BDD框架是Cucumber，它的作者是RSpec的作者之一Aslak Hellesoy。
  - 支持很多不同程序设计语言，比如，常见的Java、JavaScript、PHP等等。
- 验收测试用例的步骤定义（Step Definition）：
  - Given表示一个假设前提。比如：假定张三是一个注册用户，其用户名密码分别是xx和xx。
  - When表示具体操作。比如：当用户以用户名xx和密码xx登录。
  - Then表示对应着这个用例要验证的结果。比如：那么张三将登录成功。
- 想写好BDD的测试用例，关键点在用业务视角描述。
- 写验收测试用例的步骤定义时，人们经常忽略的点：业务测试的模型。
  - 做Web测试常用的一个模型：Page Object。
  - 它把对页面的访问封装了起来，即便是测试用例，也不应该直接操作HTML元素，而是访问不同的页面对象。
- 验收测试的方法不止BDD一种，想实例化需求（Specification by Example，SbE）也是一种常见的方法。

>软件设计

- **把函数写短。**

- 设计原则是”道“，设计模式是”术“。
  - 设计模式并不能帮你建立起知识体系，而设计原则可以。
- 单一职责原则
  - 一个模块应该仅有一个修改的原因。
  - 一个模块应该仅有对一类actor负责。actor可以理解为对系统有共同需求的人。
- 编写短函数
  - 你能看到一个模块在为多少个actor服务，就完全取决于你的分辨能力了。
  - 不同的人对于问题的答案，取决于他看问题的粒度。
  - 你看到的粒度越细，也就越能发现问题。
    - 这些方法是不是为一类actor服务。
    - 这些代码是不是在一个层面上。
    - 这个服务，是否提供一类的服务。

> 分层抽象

- **构建好你的领域模型。**
- 分层架构，实际上，就是一种在设计上的分解。
  - MVC的概念起源于GUI（Graphical User Interface，图形用户界面）编程。
    - 将图形界面上展示部分（View）与UI的数据模型（Model）分开，它们之间的联动有Controller负责。
  - 由于当时java要一行一行地写数据访问，所以，代码不太可能放在Model层，而是放在Controller里也会让代码变复杂，于是，为业务逻辑而生的Service层就呼之欲出了。
  - 由于REST服务的兴起，资源层替代了Controller层。
- 无处不在的抽象
  - 网络模型分层真正的价值：构建一个良好的抽象。
    - 可以大胆地“忽略”底层协议。
  - 编程语言也是一种抽象。
    - 可以“忽略”底层指令集。
  - Node.js的出现让Java：Script成为了一个更好的抽象。
- 构建你的抽象
  - 构建抽象，最核心的一步是构建出你的核心模型。
    - 什么是核心模型呢？就是表达你业务的那部分代码。
  - 我们习惯上称之为服务层，但这个名字其实不能很好地反映它的作用，更恰当的说法应该可以叫领域模型（Domain Model）。
    - 其领域模型中一个重要的组成部分：领域对象。
- 你的领域层只依赖于你的领域对象，第三方发过来的内容先做一次转换，转换成你的领域对象。这种做法称为防腐层。
- 当我们把领域模型看成了整个设计的核心，看待其他层的视角也会随之转变，它们只不过是适配到不同的地方的一种方式而已，而这种概念的推广，就是一些人在说的六边形架构。

>系统的发展过程

- **用简单技术解决问题，直到问题变复杂。**
- 需要知道自己面对的到底是一个什么样的系统。
- 每次随着业务量的增长，原有技术无法满足需要，于是，就需要用新的技术去解决这个问题。
  - 这里的关键点在于：不同的业务量。
- 更准确地说，不同量级的系统根本就不是一个系统。
- 淘宝的工程师之所以要改进系统，真实的驱动力不是技术，而是不断攀升的业务量带来的问题复杂度。
- 所以，评估系统当前所处的阶段，采用恰当的技术解决，是我们最应该考虑的问题。

> 微服务

- **学习领域驱动设计。**

- 微服务：新型的架构风格。
- “在企业内部将服务有组织地进行拆分”这个理念脱胎于SOA（Service Oriented Architecture，面向服务的架构）。
  - SOA诞生于自那个大企业操盘技术的年代，自身太过于复杂，没有真正流行开来。
- 怎么划分微服务，也就是一个庞大的系统按照什么样的方式分解。
- 领域驱动设计（Domain Driven Design，DDD）是Eric Evans提出的从系统分析到软件建模的一套方法论。
  - 它能将业务概念和业务规则换成软件系统中概念和规则，从而降低或隐藏业务复杂性，使系统具有更好的扩展性，以应对复杂多变的现实业务问题。
  - 它把你的思考起点，从技术的角度拉到了业务上。
  - DDD最为基础的就是通用语言（Ubiquitous Language），让业务人员和程序员说一样的语言。
- 它限定了通用语言自由使用的边界，一但出界，含义便无法保证。
  - 正是由于边界的存在，一个界限上下文刚好可以成为一个独立的部署单元，而这个部署单元就可以成为一个服务。
  - 所以要做好微服务，第一步应该是识别界限上下文。
- Martin Fowler在写《企业应用架构模式》时，提出了一个分布式对象第一定律：不要分布式对象。
  - 同样，在微服务领域也适用，想做微服务架构，首先是不要适用微服务。
  - 如果将一个整体服务贸然做成微服务，引入的复杂度会吞噬掉你以为的优势。
  - 一次性把边界划清楚不是一件容易的事。大家在一个进程里，调整起来会容易很多。
  - 让不同的界限上下文先各自独立演化，等着它演化到值得独立部署了，再来考虑微服务拆分的事情。

>问题

- 扩展持续交付
  - 延伸到运营，比如AB测试，自动选择有效的运营策略，为用户交付最大价值。
  - 精益创业实际上是一种持续验证，验证想法的有效性，获得经过验证的认知（Validated Learning）。
  - 验证数据的方式，比如AB测试。
  - AB测试是一种针对两个（或多个）变体的随机试验，常常用在Web或App的界面制作过程中，分别制作两个（或多个）版本，让两组（或多组）成分相同的用户随机访问不同版本，收集数据，用以评估哪个版本更好。
  - 一但决定了要做某个产品功能，首先应该回答的是如何收集用户数据。
  - 想要持续验证，就要做到自动化，想要自动化，就要有标注化支撑。
- Selenium和Cucumber的区别是什么？
  - Selenium是一个开源项目，它的定位是浏览器自动化，主要用于Web应用的测试。
    - 最早是Jason Huggins在2004年开发出来的，用以解决Web前端测试难的问题。
    - 之所以取名Selenium（硒），主要用于讽刺其竞争对手Mercury（水银）公司开发的产品。
  - Cucumber的兴起伴随着Ruby on Rails的蓬勃发展，Ruby on Rails是一个改变了行业认知的Web开发框架，Cucumber最初主要就是用在Web应用写测试上，而Selenium刚好是用来操作浏览器的，二者一拍即合。
  - Cucumber提供的是一层业务描述框架，而它需要有自己对应的步骤实现，以便于能够对被测系统进行操控；而Selenium就是Web应用测试方面实现步骤定义的一个非常好的工具。
- IntelliJ IDEA怎么学？
  - 不断使用它，遇到问题就去找相应的解决方案。
  - 看别人如何使用的，找到差距后，自己慢慢练习。
  - 利用记录快捷键的卡片（或者工具）去记忆和练习。

> 总结

- 持续交付
  - 将生产部署纳入了开发的考量。
  - 持续交付的基础设施通常包含持续集成环境、测试环境、预生产环境和生产环境。
  - 构建流水线保证到了下游的交付物一定是通过上游验证的。
  - 随着Docker的诞生，交付由发布包编程了Docker镜像。
- DevOps
  - 将开发和运维结合到一起。
  - 环境配置工具上的进步，让基础设施即代码成了行业共识。
- 验收测试
  - 验收测试要站在业务的角度编写。
  - BDD是一种编写验收测试的方式。
  - Given...When...Then...的描述给了一个描述业务的统一方式。
  - 写好验收测试，需要构建测试模型。
- SOLID原则
  - 设计模式背后的道理。
  - 单一职责原则（Single reponsibility principle，SRP）。
  - 开放封闭原则（Open-closed principle，OCP）。
  - Liskov替换原则（Liskov substitution principle，LSP）。
  - 接口隔离原则（Interface segregation principle，ISP）。
  - 依赖倒置原则（Dependency inversion principle，DIP）。
  - 用好单一职责原则，前提条件是看待问题颗粒度要小。
- DDD
  - 它将思考的起点拉到了业务上。
  - DDD分为战略设计和战术设计。
- 微服务
  - 做好微服务的前提是划分好限界上下文。
  - 微服务的第一步，不要划分微服务。
- 思路
  - 程序员的三大美德：懒惰、急躁和傲慢（Laziness，Impatience and hubris）。
  - 小心NIH综合征（Not Invented Here Syndrome）。
  - 写好构建脚本，做好项目自动化。
  - 参照Java知识体系，学习运维知识。
  - 软件设计最基础的原则是“高内聚、低耦合”。
  - 分层架构是一种设计上的分解。
  - 不同业务量的系统本质上不是一个系统。
  - 采用简单设计解决问题，直到问题变复杂。
- 持续集成的延伸。
  - 持续集成完成系统集成。
  - 持续交付完成可部署上线。
  - “持续验证”完成产品想法验证。
- AB测试，用一个软件的多个版本的自动化。
- 熟练使用快捷键。

### 七、综合运用

> 新入职一家公司，怎样快速进入工作状态？

- **了解一个项目，从大图景开始。**

- 运用思考框架
  - Where are we？（我们现在在哪？）
    - 对公司业务有一个简单地了解。
  - Where are we going？（我们要到哪儿去？）
    - 将目标制定成能够达到上手工作的程度，比如，能够解决日常的项目问题。
  - How can we get there？（我们如何到达那里？）
    - 做任务分解。
- 技术解决的是“怎么做”的问题，而我们第一个应该了解的问题是“做什么”。
- 知识结构很重要，只有了解了大图景，各种知识才能各归其位。
- 业务。
  - 如果是我做这个业务，我会怎么做。
  - 请人给我讲一下，这个业务是做什么的，解决什么样的问题，具体的业务流程是什么样子的，等等。
  - 别把业务和技术混淆了，你要了解的只是业务。
- 技术。
  - 技术栈，比如java、javaScript。
  - 系统的业务架构，这个系统包含了哪些模块，与哪些外部系统有交互等等。
  - 如果没有架构图，那就一起讨论写出来，之后再慢慢整理。
  - 外部
    - 这个系统对外提供哪些接口，这对应着系统提供的能力。
    - 这个系统需要集成哪些外部系统，对应着它需要哪些支持。
  - 内部
    - 这个系统由哪些模块组成，每个模块承担怎样的职责。（分清界限上下文）
    - 一个模块内部分了多少层，每层的职责是什么。
    - 从构建脚本开始，了解项目的常用命令。
    - 代码的目录结构、配置文件的位置、模块在源代码的体现等等。
- 团队运作。
  - 外部
    - 需求时从哪来的，产品最终会有谁使用，团队需要向谁汇报。
    - 如果有外部客户，日常沟通是怎么安排的。
  - 内部
    - 站会、回顾会议、周会，这些不同活动的时间安排是怎样的。
    - 是否有每天的代码评审、是否有内部的分享机制等等。
- 从大到小，由外而内，将要了解的内容层层分解，有了大图景之后，很容易知道自己做的事情到底在整体上处于什么样的位置。

>面对遗留系统，你应该这样做

- **小步改造遗留系统，不要回到老路上。**

- 运用思考框架
  - Where are we？（我们现在在哪？）
    - 遗留系统和烂代码到底是不是问题呢？其实并不是，他们只是现象，不是根因。
    - 比如，实现一个直觉上需要两天的需求，要做两周或更长的时间，根因是代码耦合太严重，改动影响的地方太多；
    - 比如，性能优化遇到瓶颈，怎么改延迟都降不下来，根因是架构设计有问题，等等。
    - 复盘找根因。
  - Where are we going？（我们要到哪儿去？）
    - 目标是：重写某些代码。
    - 先尝试重构你的代码，尽可能在已有代码上做小步调整，不要走到大规模改造的路上，因为重构的成本是最低的。
  - How can we get there？（我们如何到达那里？）
    - 只有当你构建器测试防护网了，后续的修改才算是走在坚实的道路上。
    - 遗留代码就是没有测试的代码。
    - 替换遗留系统：分成小块，逐步替换。
    - 新代码要怎么写：一方面，建立好领域模型，另一方面，寻找行业对于系统构建的最新理解。

> 如何保持竞争力

- **在学习区工作和成长。**

- 现状：焦虑。
  - 我们的焦虑来自于对未来的不确定性，而这种不确定性是一个特定时代加上特定行业的产物。
  - 从长期来看，只要生活中还有需要用自动化解决的问题，程序员这个群体还是很有前景的。
  - 但随着时间的推移，程序员这个职业的溢价也会越来越低，单纯凭借身处这个行业就获得好发展的可能性也越来越低。
- 目标：成为T型人。
  - 什么是T型人？简言之，一专多能。
  - 有了“一专”，“多能”才是有意义的，否则，就是低水平重复，而这正是很多人职业生涯不见起色的真正原因。
  - 这里的“专”不是熟练，而是深入。
    - 你会发现很多优秀的人，在很多方面都会很优秀，这是“一专”带来的触类旁通。
  - 比如，我拥有了深厚的技术功底，通晓怎么做软件：
    - 如果还能够带着其他人一起做好，就成了技术领导者。
    - 如果能够分享技术的理解，就有机会成为培训师。
    - 如果能够在实战中帮助别人解决问题，就可以成为咨询师。
  - 反过来，当你有了“多能”，也可以拓宽你的视野，帮你认清自己的“一专”怎样更好地发挥价值，而不是狭隘地认为自己有了技术，就已经天下尽在掌握了。
  - 只做一个公司的专家，受一个公司的波动影响太大，而成为行业的专家，才会降低自己职业生涯的风险。
- 怎么达到目标：向行业中的大师学习。
  - 读大师级程序员的作品，以及Kent Beck、Martin Fowler和Robert Martin等这些人的作品。
  - 读这些书的好处在于，你的视野会打开，不会把目标放在“用别人已经打造好的工具做一个特定的需求”。
- 怎么才能让自己的水平不断提高呢？找一个好的问题去解决。
  - 如果你还什么都不会，那有一份编程的工作就好。
  - 如果你已经能够写好普通的代码，就应该尝试去编写程序库。
  - 如果实现一个具体功能都没问题了，那就去做设计，让程序有更好的组织。
  - 如果你已经能完成一个普通的系统设计，那就应该去设计业务量更大的系统。
- Noel Tichy提出了一个“学习区”模型。
  - 最内层是舒适区（Comfort Zone），置身其中会让人感觉良好，但也会因为没有挑战，成长甚微，你可以把它理解成做你最熟悉的事情。
  - 最外层是恐慌区（Panic Zone），这是压力极大的地方，完全超出了你的能力范围，你在其中只会感到无比的焦虑。
  - 中间是学习区（learning Zone），事情有难度，又刚好是你努力一下可以完成的，这才是成长最快的区域。

> 问题

- 如何在实际工作中推行新观念？
  - 找到愿意和你一起改变的人，做一件具体的事。
    - 在实际情况中，想在一个组织内推广一些不一样的东西，都会面临层层阻力。
    - 有愿意和你一起改变的人是一件幸运的事，别指望所有人一下子和你走上同一条道路。
    - 想做事，只需要一个理由就够了，不想做，理由有一万个。
  - Talk is cheap. Show me the code.
    - 讲道理很容易，但也难以让人真正的信服。同样，做事很难，但成果摆在那里，让人不得不信服。
  - Lead by Example
    - 通常用来形容团队领导以身作则的形式风格。
    - 当你需求改变时，无论你的角色是什么，你都需要扮演好领导者的角色。
- 测试怎么写？
  - 你要测的是什么？
  - 外部系统对你来说，应该只是一个接口。
  - 设计一个接口，让业务代码依赖于这个接口，而第三方依赖都放在这个接口的一个具体实现中。
  - 如果有任何外部系统，都要设计防腐层，用接口做隔离。
  - 关于外部系统的测试，你可以先通过接口隔离开来，然后，通过模拟服务或本地可控的方式进行测试。

> 总结

- “学习区”学习模型。
  - 舒适区，舒适而缺乏成长。
  - 恐慌区，超出能力范围。
  - 学习区，有难度而可以达成。
  - 在学习区练习才能得到足够的成长。
- T型人才，一专多能。
  - 知识的广度。
  - 专业技能的深度。
  - 有“一专”，“多能”才是有意义的。
- 进入新工作，从全面了解了解开始
  - 业务：做什么。
  - 技术：怎么做。
  - 团队运作：怎么与人协作。
  - 从大到小，由外及内地了解工作。
- 面对遗留系统，稳扎稳打，小步前行。
  - 基础理念。
    - 烂代码知识现象，要了解根因。
    - 能重构，先重构，大规模改造是迫不得已的选择。
    - 小步前行。
  - 实际操作。
    - 构建测试防护网。
    - 将大系统分解成小模块，逐步替换。
    - 新旧模块并存，由分发模块调度。
    - 建立好领域模型。
    - 寻找行业对于系统构建的最新理解。
- 程序员的职业发展。
  - 程序员的焦虑来自对未来的不确定性，这种不确定性是一个特定时代加上特定行业的产物。
    - 快速发展的中国经济。
    - 程序员在中国是一个新兴职业。
  - 成为行业专家，指定高目标。
  - 向大师学习，开阔视野。
  - 找到好的问题，和高水平的人一起工作。
- 推行新观念，找愿意改变的人，做具体的事。
- Lead by Example。
- 外部系统应用接口隔离，这种做法体现了接口隔离原则（ISP），也是防腐层概念的体现。
- 外部系统的测试，能模拟的就模拟，能本地的就本地。

> 少做事，才能更有效地工作

- 算法的差异
  - 尽可能利用已知的信息，少做不必要的事。
- 有效工作
  - 少写代码，多考虑设计。
  - 工作效率高，不是因为代码写得多，而是有效工作做得多。
  - 有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。
- 如何有效工作
  - 扩展自己的上下文，看到真正的目标。
    - 多了解用户，才不至于做错了方向。
    - 站在公司的层面上，才知道哪个任务优先级更高。
    - 站在行业的角度，而不局限于只在公司内成为高手。
  - 去掉不必要的内容，减少浪费。
    - 花时间分析需求，不做非必要的功能。
    - 花时间做好领域设计，别围着特定技术打转。
    - 花时间做好自动化，把精力集中在编码上。
  - 要想有效工作，有两个重要点：
    - 意识上要注意自己工作中无效的部分。
    - 要构建自己关于软件开发的知识体系。


### 八、程序员段子

做软件，最理想的交付日期是什么时候？答案是昨天，其次是尽快。

就差一个程序员了。

对程序员最好的惩罚是让他维护自己三个月前写的代码。

甲方想要做个电商网站，作为乙方的程序员问：“你要做个什么样的呢？”甲方说：“像淘宝那样就好。”程序员问：“那你打算出多少钱？”甲方想了想，“5 万块钱差不多了吧！”

### 九、推荐书单

- 编码实践
  - **《代码整洁之道》**——Robert Martin
    - 详细学习如何写好代码。
  - 《**实现模式**》——Kent Beck
    - 如何写好代码，写出别人能够理解的代码。
  - 《**程序设计实践**》（The Practice of Programming）——Brian Kernighan、Rob Pike。
    - 看大师编程。
  - 《**卓有成效的程序员**》
    - 看一些不同的工作方式。

- 设计
  - 《**敏捷软件开发：原则、实践与模式**》——Robert Martin
    - SOLID原则。
  - 《**架构整洁之道**》（Clean Architecture）——Robert Martin
    - 设计和架构没有区别，可以看作敏捷软件开发的修订版。
  - 《设计模式》——Erich Gamma
    - 不建议阅读，比较偏学术，翻译很一般。
  - 《**Head First 设计模式**》
    - 入门设计模式。
  - 《**企业应用架构模式**》——Martin Fowler
    - 将软件开发时常见的解决方案汇集成模式。
  - 《**Unix编程艺术**》——Eric Raymond
    - 只做一件事，把它做好。
- 工程实践
  - 《极限编程》——Kent Beck
  - **《解析极限编程》**——Kent Beck
    - 很多主流的软件最佳实践都是从这里出来的。
  - 《**重构：改善既有代码的设计**》——Martin Fowler
  - **《重构》中文第二版**——Martin Fowler
    - 时隔近20年的新版。
  - 《**重构与模式**》
    - 目标：重构成模式。
  - 《**测试驱动开发**》——Kent Beck
    - 任务分解。
  - 《**持续交付**》——Jez Humble、Dave Farley。
    - 持续集成的再进一步。
  - 《**持续交付2.0**》——乔梁
  - 《**修改代码的艺术**》（Working Effectively with Legacy Code）——Michael Feathers
    - 处理遗留代码。
- 领域驱动设计
  - 《领域驱动设计》（Domain Driven Design）——Eric Evans，2003
    - 开山之作。
  - 《实现领域驱动设计》——Vaughn Vernon
    - 十年的精华。
  - 《**领域驱动设计精粹**》——Vaughn Vernon
    - 快速上手DDD。
- 产品与需求
  - 《**精益创业**》——Eric Ries
  - 《**Scrum敏捷软件开发**》——Mike Cohn
  - 《用户故事与敏捷方法》——Mike Cohn
  - 《敏捷软件开发实践 估算与计划》——Mike Cohn
- 开发文化
  - 《**人月神话**》
    - 银弹、焦油坑等概念的提出。
  - 《**大教堂与集市**》——Eric Raymond
    - 开源历程。
  - 《**程序员的职业素养**》（Clean Coder）——Robert Martin
    - 学会说“不”。
- 软件开发拾遗
  - 《计算机程序设计艺术》——Donald Knuth（高德纳）
    - 看图灵奖获得者如何从根上思考问题。
  - 《快速软件开发》（Rapid Development）
  - 《C程序设计语言》
  - 《Unix编程环境》
  - 《淘宝技术这十年》
- 函数式编程
  - 《计算机程序的解释与构造》（Structure and Interpretation of Computer Programs，SICP）
  - 《Haskell 趣学指南》（Learn You a Haskell for Great Good!）
  - 《函数式编程思维》（Functional Thinking）
- 技术之外
  - 《人类简史》
  - 《未来简史》
  - 《三体》
  - 《银河帝国》——阿西莫夫
  - 《**卓有成效的管理者**》
    - 一本告诉我们如何工作的书。
  - 《从一到无穷大》
    - 一本著名科普著作。
  - **《高效能人士的七个习惯》**——史蒂芬 柯维
    - 以终为始、艾森豪威尔矩阵、智力创造概念的提出。
  - 《**心流**》——米哈里 契克森米哈赖
    - 最好的工作状态是进入心流。















































